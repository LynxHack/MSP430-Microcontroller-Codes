//Test 3
//EXERCISE 7.4B   ADC Done with Interrupt from Timer for Sampling and not while loop (40ms sample rate)
//#include <msp430.h>
//
//#pragma vector=USCIAB0RX_VECTOR // defined in "msp430x22x4.h" For test use
//__interrupt void UART_RX(void) // interrupt on incoming data
//{
////    unsigned char rx_byte;
////    rx_byte = UCA0RXBUF; // grab byte from RX buffer
////
////    while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
////    UCA0TXBUF = rx_byte;  // Echo the byte back X
//}
//
//
//volatile unsigned int Result;
//volatile unsigned int valueflag = 0;
//#pragma vector=ADC10_VECTOR
//__interrupt void ADC10_ISR(void)
//{
//    while((ADC10CTL1 & ADC10BUSY)!=0);
//    Result = ADC10MEM >> 2;
//    while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//    UCA0TXBUF = Result;  // Echo the byte back X
//    valueflag = 0; //clear flag now that value is written out
////    valueflag = 1;
//     ADC10CTL0 &= ~ADC10IFG;
//}
//
//volatile unsigned int state = 1;
//#pragma vector=TIMERB0_VECTOR //Triggers every rising edge capture (set to 40ms in this example)
//__interrupt void Timer_B(void)
//{
//    TBCTL &= ~CCIFG;
//    P1OUT ^= BIT7;                      // Toggle P1.0 using exclusive-OR
//    ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//    ADC10CTL1 = INCH3 + INCH2 + INCH0;  //A13 ACCX
//    ADC10CTL1 |= ADC10SSEL1 + ADC10SSEL0;
//    ADC10AE1 = BIT5; //A13 select
//    ADC10SA = 0x0200;                         // Data buffer start
//    ADC10CTL0 |= ENC + ADC10SC;               // Start sampling
//}
//
//int main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq //DIVA0 for divide 2 on ACLK
//    BCSCTL2 = SELM0 + SELM1 + SELS + DIVS0 + DIVS1;       // XT1 -> MCLK, XT1 -> SMCLK
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//    TBCTL = TBSSEL0 + MC1;  //TBSSEL0 = TBCLK, MC1 = Cont. mode (Counts up to TBCL0)
//    TBCCTL0 = CAP + CCIE + CM0; //Rising Edge Capture, Enable interrupt,
//
//    P4SEL = BIT0;         //P4.0  For connecting Timer B input (need to connect source clock to this pin)
//
//    TACTL = TASSEL_2 + MC0 + ID1 + ID0;                  // SMCLK, up mode  CLOCK divide by two on timer side
//    TACCR0 = 12498 - 1;                         // 25Hz (40ms)
//    TACCR1 = (int)TACCR0 * 0.5;                 //50% duty cycle
//    TACCTL1  = OUTMOD_7;                          // TACCR1 25% PWM duty cycle
//
//    P1DIR = BIT6 + BIT5 + BIT7; //SET pins as output
//    P1SEL |= BIT6 + BIT5;   //SELECT pin 6
//
//
//
////    ADC10CTL0 = ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
////    ADC10CTL1 = INCH3 + INCH2 + INCH1 + INCH0 + ADC10SSEL1 + ADC10SSEL0 + CONSEQ1;  //A15 ACCZ
////    ADC10AE1 = BIT7; //A15 select
////    ADC10SA = 0x0200;                         // Data buffer start
////    ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
//
//    P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//    UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//    UCA0BR0 = 1666 & 0xFF;                // Set baud rate
//    UCA0BR1 = 1666 >> 8;
//    UCA0MCTL = UCBRS_6;                   // Set modulation bits
////    IE2 |= UCA0RXIE;                      // Enable Rx interrupt
//    _EINT();
//
//    while(1){
////        if(valueflag == 1){
////            while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
////            UCA0TXBUF = Result;  // Echo the byte back X
////            valueflag = 0; //clear flag now that value is written out
//        }
//}
//

//Test 2
//#include <msp430.h>
//volatile unsigned int Result;
//volatile unsigned int valueflag = 0;
//volatile double fraction;
//#pragma vector=ADC10_VECTOR
//__interrupt void ADC10_ISR(void)
//{
//    while((ADC10CTL1 & ADC10BUSY)!=0);
//    Result = ADC10MEM >> 2;
////    fraction = (double)Result/(double)255;
//    valueflag = 1;
//     ADC10CTL0 &= ~ADC10IFG;
//}
//
//volatile unsigned int state = 1;
//#pragma vector=TIMERB0_VECTOR //Triggers every rising edge capture (set to 40ms in this example)
//__interrupt void Timer_B(void)
//{
//    TBCTL &= ~CCIFG;
//    ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//    ADC10CTL1 = INCH3 + INCH2;  //A12
//    ADC10CTL1 |= ADC10SSEL1 + ADC10SSEL0;
//    ADC10AE1 = BIT4; //A13 select
//    ADC10SA = 0x0200;                         // Data buffer start
//    ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
//}
//
//int main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq //DIVA0 for divide 2 on ACLK
//    BCSCTL2 = SELM0 + SELM1 + SELS;       // XT1 -> MCLK, XT1 -> SMCLK
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//    TBCTL = TBSSEL0 + MC1;  //TBSSEL0 = TBCLK, MC1 = Cont. mode (Counts up to TBCL0)
//    TBCCTL0 = CAP + CCIE + CM0; //Rising Edge Capture, Enable interrupt,
//
//    P4SEL = BIT0;         //P4.0  For connecting Timer B input (need to connect source clock to this pin)
//
//    TACTL = TASSEL_2 + MC0 + ID1 + ID0;                  // SMCLK, up mode  CLOCK divide by two on timer side
//    TACCR0 = 10000 - 1;                         // 25Hz (40ms)
//    TACCR1 = (int)TACCR0 * 0.5;                 //50% duty cycle
//    TACCTL1  = OUTMOD_7;                          // TACCR1 25% PWM duty cycle
//
//    P1DIR = BIT6 + BIT5; //SET pins as output
//    P1SEL |= BIT6 + BIT5;   //SELECT pin 6
//
//    ADC10CTL0 = ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//    ADC10CTL1 = INCH3 + INCH2 + ADC10SSEL1 + ADC10SSEL0 + CONSEQ1;  //A15 ACCZ Repeat Single Channel
//    ADC10AE1 = BIT4; //A12 select
//    ADC10SA = 0x0200;                         // Data buffer start
//    ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
//
//    P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//    UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//    UCA0BR0 = 1666 & 0xFF;                // Set baud rate
//    UCA0BR1 = 1666 >> 8;
//    UCA0MCTL = UCBRS_6;                   // Set modulation bits
////    IE2 |= UCA0RXIE;                      // Enable Rx interrupt
//    _EINT();
//
//    while(1){
//        if(valueflag == 1){
//            while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//            UCA0TXBUF = Result;  // Echo the byte back X
//
//            TACTL = TASSEL_2 + MC0 + ID1 + ID0;                  // SMCLK, up mode  CLOCK divide by two on timer side
//            TACCR0 = 10000 - 1;                         // 25Hz (40ms)
//            fraction = (double)Result/(double)255;
//            TACCR1 = (int)((double)TACCR0 * (double)fraction);                 //50% duty cycle
//            TACCTL1  = OUTMOD_7;                          // TACCR1 25% PWM duty cycle
//
//            valueflag = 0; //clear flag now that value is written out
//        }
//    };
//}
//#include <msp430.h>
//volatile unsigned int Result;
//volatile unsigned int valueflag = 0;
//#pragma vector=ADC10_VECTOR
//__interrupt void ADC10_ISR(void)
//{
//    while((ADC10CTL1 & ADC10BUSY)!=0);
//    Result = ADC10MEM >> 2;
//    valueflag = 1;
//     ADC10CTL0 &= ~ADC10IFG;
//}
//
////volatile unsigned int state = 1;
////#pragma vector=TIMERB0_VECTOR //Triggers every rising edge capture (set to 40ms in this example)
////__interrupt void Timer_B(void)
////{
////    TBCTL &= ~CCIFG;
////    ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
////    ADC10CTL1 = INCH3 + INCH2;  //A12
////    ADC10CTL1 |= ADC10SSEL1 + ADC10SSEL0;
////    ADC10AE1 = BIT4; //A13 select
////    ADC10SA = 0x0200;                         // Data buffer start
////    ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
////}
//
//int main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq //DIVA0 for divide 2 on ACLK
//    BCSCTL2 = SELM0 + SELM1 + SELS;       // XT1 -> MCLK, XT1 -> SMCLK
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
////
////    TBCTL = TBSSEL0 + MC1;  //TBSSEL0 = TBCLK, MC1 = Cont. mode (Counts up to TBCL0)
////    TBCCTL0 = CAP + CCIE + CM0; //Rising Edge Capture, Enable interrupt,
//
////    P4SEL = BIT0;         //P4.0  For connecting Timer B input (need to connect source clock to this pin)
//
//    TACTL = TASSEL_2 + MC0 + ID1 + ID0;                  // SMCLK, up mode  CLOCK divide by two on timer side
//    TACCR0 = 10000 - 1;                         // 25Hz (40ms)
//    TACCR1 = (int)TACCR0 * 0.5;                 //50% duty cycle
//    TACCTL1  = OUTMOD_7;                          // TACCR1 25% PWM duty cycle
//
//    P1DIR = BIT6 + BIT5; //SET pins as output
//    P1SEL |= BIT6 + BIT5;   //SELECT pin 6
//
//    ADC10CTL0 = ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//    ADC10CTL1 = INCH3 + INCH2 + ADC10SSEL1 + ADC10SSEL0 + CONSEQ1;  //A15 ACCZ Repeat Single Channel
//    ADC10AE1 = BIT4; //A12 select
//    ADC10SA = 0x0200;                         // Data buffer start
//    ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
//
//    P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//    UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//    UCA0BR0 = 1666 & 0xFF;                // Set baud rate
//    UCA0BR1 = 1666 >> 8;
//    UCA0MCTL = UCBRS_6;                   // Set modulation bits
////    IE2 |= UCA0RXIE;                      // Enable Rx interrupt
//    _EINT();
//
//    while(1){
//        ADC10CTL0 = ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//        ADC10CTL1 = INCH3 + INCH2 + ADC10SSEL1 + ADC10SSEL0 + CONSEQ1;  //A15 ACCZ Repeat Single Channel
//        ADC10AE1 = BIT4; //A12 select
//        ADC10SA = 0x0200;                         // Data buffer start
//        ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously                    // TACCR1 25% PWM duty cycle
//        while((IFG2 & UCA0TXIFG) == 0); // R
//        UCA0TXBUF = Result;  // Echo the byte back
//    };
//}


//Test 1
//EXERCISE 5.3   Timer Up Count Mode Pin 1.6 output 500 Hz, 25% duty
//#include <msp430.h>
//
//int main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//    BCSCTL2 = SELM0 + SELM1 + SELS + DIVS0;       // XT1 -> MCLK, XT1 -> SMCLK Divde by 4
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//      P1DIR |= BIT6; //SET pins as output
//      P1SEL |= BIT6;   //SELECT pin 6
//
//  TACCR0 = 1333 - 1;                         // PWM Period 500,000Hz / 1000
//  TACCTL1 = OUTMOD_7;           //PIN 1.6            // TACCR1 reset/set
//  TACCR1 = (int)TACCR0*0.30;                             // TACCR1 25% PWM duty cycle
//
//  TACTL = TASSEL_2 + MC_1 + ID0;                  // SMCLK, up mode  CLOCK divide by eight on timer side
//
//  for(;;){
//
//  }
////  __bis_SR_register(CPUOFF);                // Enter LPM0
//}

////EXERCISE 10 - Circular buffer with 5 byte data package
//#include <msp430.h>
//#define BUFFER_SIZE  50
//
//volatile unsigned int top = 0;  //ind = (ind + 1) % 50;
//volatile unsigned int end = 0;
//volatile unsigned int size = 0;
//volatile unsigned char rx_byte;
//int buffer[BUFFER_SIZE];
//int writeflag = 0;
//
//#pragma vector=USCIAB0RX_VECTOR // defined in "msp430x22x4.h"
//__interrupt void UART_RX(void) // interrupt on incoming data
//{
//    buffer[end] = UCA0RXBUF; // grab byte from RX buffer
//    if(end==50){
//        end = 0;
//    }
//    else{
//        end = end + 1;
//    }
//    size = size + 1;
//}
//
//void main(void)
//{
//    unsigned int Packet[5];
//    unsigned int i;
//    unsigned int sixteenBitNumber;
//    WDTCTL = WDTPW + WDTHOLD;             // Stop watchdog timer
//
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//    BCSCTL2 = SELM0 + SELM1 + SELS;       // XT1 -> MCLK, XT1 -> SMCLK
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//    TBCTL = TBSSEL0 + MC1;
//    TBCCTL0 = CAP + CCIE + CM1;
//
//    P4SEL = BIT0;
//
//    TACTL = TASSEL0 + MC0;                  // SMCLK, up mode  CLOCK divide by two on timer side
//    TACCR0 = 32000 - 1;                         // PWM Period 500,000Hz / 1000
//    TACCTL0 = OUTMOD2;                       // TACCR1 reset/set
////    TACCR1 = (int)TACCR0 * 0.25;
//    TACCR1 = (int)TACCR0;
//    TACCTL1  = OUTMOD_7;                          // TACCR1 25% PWM duty cycle
//
//    P1DIR |= (BIT0+BIT1+BIT2+BIT3+BIT4+BIT5+BIT6+BIT7);
//    P1SEL |= BIT6 + BIT5;   //SELECT pin 6
//
//    P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//
//    UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//    UCA0BR0 = 1666 & 0xFF;                // Set baud rate
//    UCA0BR1 = 1666 >> 8;
//    UCA0MCTL = UCBRS_6;                   // Set modulation bits
//    IE2 |= UCA0RXIE;                      // Enable Rx interrupt
//
//    _EINT();      // Global interrupt enable
//
//    while (1){
//       if(size>=5){
//            for(i=0; i<5; i++){
//                Packet[i] = buffer[top];
//                top = (top+1)%BUFFER_SIZE;
//                size--;
//            }
//            while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//            if(Packet[4]!= 0){  //Escape byte check
//                if(Packet[4]==1){
//                    Packet[2] = 0xFF;
//                }
//                else if(Packet[4] == 2){
//                    Packet[3] = 0xFF;
//                }
//                else if(Packet[4] == 3){
//                    Packet[2] = 0XFF;
//                    Packet[3] = 0XFF;
//                }
//            }
//            sixteenBitNumber = (Packet[3]<<8) | Packet[2]; //Upper and lower bytes merge
//            // TACCR1 reset/set
////            TACCR1 = (int)TACCR0 * sixteenBitNumber/65535;
//            double fraction = (double)sixteenBitNumber / (double)65535;
//            TACCR1 = (int)TACCR0 *fraction;
//
//            if(Packet[1] == 2){
//                      P1DIR |= (BIT0+BIT1+BIT2+BIT3+BIT4+BIT5+BIT6+BIT7);
//                        P1OUT |= BIT7;                      // Toggle P1.0 using exclusive-OR
//            }
//            else if(Packet[1] == 3){
//                P1OUT &= ~BIT7;                      // Toggle P1.0 using exclusive-OR
//            }
//
//            UCA0TXBUF = sixteenBitNumber;
//        }
//    }
//}


////EXERCISE 9 Circular Buffer
//#include <msp430.h>
//#define BUFFER_SIZE  50
//
//volatile unsigned int top = 0;  //ind = (ind + 1) % 50;
//volatile unsigned int end = 0;
//volatile int size = 0;
//int buffer[BUFFER_SIZE];
//
//#pragma vector=USCIAB0RX_VECTOR // defined in "msp430x22x4.h"
//__interrupt void UART_RX(void) // interrupt on incoming data
//{
//    unsigned char rx_byte;
//    rx_byte = UCA0RXBUF; // grab byte from RX buffer
//
//    if(rx_byte != 13 && (size<0 || size>50)){
//        while((IFG2 & UCA0TXIFG) == 0); // E
//        UCA0TXBUF = 0x45;  // Echo the byte back
//        while((IFG2 & UCA0TXIFG) == 0); // R
//        UCA0TXBUF = 0x52;  // Echo the byte back
//        while((IFG2 & UCA0TXIFG) == 0); // R
//        UCA0TXBUF = 0x52;  // Echo the byte back
//        while((IFG2 & UCA0TXIFG) == 0); // O
//        UCA0TXBUF = 0x4F;  // Echo the byte back
//        while((IFG2 & UCA0TXIFG) == 0); // R
//        UCA0TXBUF = 0x52;  // Echo the byte back
//    }
//
//    else if(rx_byte != 13){
//        buffer[end] = rx_byte;
//        end = (end+1)%BUFFER_SIZE; //circular buffer return to first index if exceed 50
//        size++;
//    }
//
//    else if(rx_byte == 13 && size>0){
//        while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//        UCA0TXBUF = buffer[top];  // Echo the byte back
//        top = (top+1)%BUFFER_SIZE;  //Shift array to delete the element - ready to be overwritten
//        size--;
//    }
//}
//
//void main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;             // Stop watchdog timer
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//    BCSCTL2 = SELM0 + SELM1 + SELS;       // XT1 -> MCLK, XT1 -> SMCLK
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//    P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//
//    UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//    UCA0BR0 = 1666 & 0xFF;                // Set baud rate
//    UCA0BR1 = 1666 >> 8;
//    UCA0MCTL = UCBRS_6;                   // Set modulation bits
//    IE2 |= UCA0RXIE;                      // Enable Rx interrupt
//
//    _EINT();      // Global interrupt enable
//    while (1);
//}

//EXERCISE 8 ADCII Measure voltage

//#include <msp430.h>
//volatile unsigned int Result;
//volatile unsigned int valueflag = 0;
//#pragma vector=ADC10_VECTOR
//__interrupt void ADC10_ISR(void)
//{
//    while((ADC10CTL1 & ADC10BUSY)!=0);
//    Result = ADC10MEM >> 2;
//    valueflag = 1;
//     ADC10CTL0 &= ~ADC10IFG;
//}
//
//volatile unsigned int state = 1;
//#pragma vector=TIMERB0_VECTOR //Triggers every rising edge capture (set to 40ms in this example)
//__interrupt void Timer_B(void)
//{
//    TBCTL &= ~CCIFG;
//    ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//    ADC10CTL1 = INCH3 + INCH2;  //A12
//    ADC10CTL1 |= ADC10SSEL1 + ADC10SSEL0;
//    ADC10AE1 = BIT4; //A13 select
//    ADC10SA = 0x0200;                         // Data buffer start
//    ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
//}
//
//int main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq //DIVA0 for divide 2 on ACLK
//    BCSCTL2 = SELM0 + SELM1 + SELS;       // XT1 -> MCLK, XT1 -> SMCLK
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//    TBCTL = TBSSEL0 + MC1;  //TBSSEL0 = TBCLK, MC1 = Cont. mode (Counts up to TBCL0)
//    TBCCTL0 = CAP + CCIE + CM0; //Rising Edge Capture, Enable interrupt,
//
//    P4SEL = BIT0;         //P4.0  For connecting Timer B input (need to connect source clock to this pin)
//
//    TACTL = TASSEL_2 + MC0 + ID1 + ID0;                  // SMCLK, up mode  CLOCK divide by two on timer side
//    TACCR0 = 10000 - 1;                         // 25Hz (40ms)
//    TACCR1 = (int)TACCR0 * 0.5;                 //50% duty cycle
//    TACCTL1  = OUTMOD_7;                          // TACCR1 25% PWM duty cycle
//
//    P1DIR = BIT6 + BIT5; //SET pins as output
//    P1SEL |= BIT6 + BIT5;   //SELECT pin 6
//
//    ADC10CTL0 = ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//    ADC10CTL1 = INCH3 + INCH2 + ADC10SSEL1 + ADC10SSEL0 + CONSEQ1;  //A15 ACCZ Repeat Single Channel
//    ADC10AE1 = BIT4; //A12 select
//    ADC10SA = 0x0200;                         // Data buffer start
//    ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
//
//    P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//    UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//    UCA0BR0 = 1666 & 0xFF;                // Set baud rate
//    UCA0BR1 = 1666 >> 8;
//    UCA0MCTL = UCBRS_6;                   // Set modulation bits
////    IE2 |= UCA0RXIE;                      // Enable Rx interrupt
//    _EINT();
//
//    while(1){
//            TBCTL &= ~CCIFG;
//            ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//            ADC10CTL1 = INCH3 + INCH2;  //A12
//            ADC10CTL1 |= ADC10SSEL1 + ADC10SSEL0;
//            ADC10AE1 = BIT4; //A13 select
//            ADC10SA = 0x0200;                         // Data buffer start
//            ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
//            while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//            UCA0TXBUF = Result;  // Echo the byte back X
//            valueflag = 0; //clear flag now that value is written out
//    };
//}




////EXERCISE 9 Circular Buffer
//#include <msp430.h>
//#define BUFFER_SIZE  50
//
//volatile unsigned int top = 0;  //ind = (ind + 1) % 50;
//volatile unsigned int end = 0;
//volatile int size = 0;
//int buffer[BUFFER_SIZE];
//
//#pragma vector=USCIAB0RX_VECTOR // defined in "msp430x22x4.h"
//__interrupt void UART_RX(void) // interrupt on incoming data
//{
//    unsigned char rx_byte;
//    rx_byte = UCA0RXBUF; // grab byte from RX buffer
//
//    if(rx_byte != 13 && (size<0 || size>50)){
//        while((IFG2 & UCA0TXIFG) == 0); // E
//        UCA0TXBUF = 0x45;  // Echo the byte back
//        while((IFG2 & UCA0TXIFG) == 0); // R
//        UCA0TXBUF = 0x52;  // Echo the byte back
//        while((IFG2 & UCA0TXIFG) == 0); // R
//        UCA0TXBUF = 0x52;  // Echo the byte back
//        while((IFG2 & UCA0TXIFG) == 0); // O
//        UCA0TXBUF = 0x4F;  // Echo the byte back
//        while((IFG2 & UCA0TXIFG) == 0); // R
//        UCA0TXBUF = 0x52;  // Echo the byte back
//    }
//
//    else if(rx_byte != 13){
//        buffer[end] = rx_byte;
//        end = (end+1)%BUFFER_SIZE; //circular buffer return to first index if exceed 50
//        size++;
//    }
//
//    else if(rx_byte == 13 && size>0){
//        while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//        UCA0TXBUF = buffer[top];  // Echo the byte back
//        top = (top+1)%BUFFER_SIZE;  //Shift array to delete the element - ready to be overwritten
//        size--;
//    }
//}
//
//void main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;             // Stop watchdog timer
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//    BCSCTL2 = SELM0 + SELM1 + SELS;       // XT1 -> MCLK, XT1 -> SMCLK
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//    P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//
//    UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//    UCA0BR0 = 1666 & 0xFF;                // Set baud rate
//    UCA0BR1 = 1666 >> 8;
//    UCA0MCTL = UCBRS_6;                   // Set modulation bits
//    IE2 |= UCA0RXIE;                      // Enable Rx interrupt
//
//    _EINT();      // Global interrupt enable
//    while (1);
//}


//EXERCISE 7.4B   ADC Done with Interrupt from Timer for Sampling and not while loop (40ms sample rate)
//#include <msp430.h>
//
//volatile unsigned int top = 0;  //ind = (ind + 1) % 50;
//volatile unsigned int end = 0;
//volatile int size = 0;
//int buffer[16];
//
//#pragma vector=USCIAB0RX_VECTOR // defined in "msp430x22x4.h" For test use
//__interrupt void UART_RX(void) // interrupt on incoming data
//{
//    unsigned char rx_byte;
//    rx_byte = UCA0RXBUF; // grab byte from RX buffer
//
//    while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//    UCA0TXBUF = rx_byte;  // Echo the byte back X
//}
//
//
//volatile unsigned int Result;
//volatile unsigned int valueflag = 0;
//#pragma vector=ADC10_VECTOR
//__interrupt void ADC10_ISR(void)
//{
//    while((ADC10CTL1 & ADC10BUSY)!=0);
//    Result = ADC10MEM >> 2;
//    valueflag = 1;
//     ADC10CTL0 &= ~ADC10IFG;
//}
//
//volatile unsigned int state = 1;
//#pragma vector=TIMERB0_VECTOR //Triggers every rising edge capture (set to 40ms in this example)
//__interrupt void Timer_B(void)
//{
//    TBCTL &= ~CCIFG;
//        P1OUT ^= BIT7;                      // Toggle P1.0 using exclusive-OR
//    if(state == 1){
//        state = 2;
//        ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//        ADC10CTL1 = INCH3 + INCH2 + INCH0;  //A13 ACCX
//        ADC10CTL1 |= ADC10SSEL1 + ADC10SSEL0;
//        ADC10AE1 = BIT5; //A13 select
//        ADC10SA = 0x0200;                         // Data buffer start
//        ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
//        state = 1;
//    }
//}
//int average = 0;
//int main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq //DIVA0 for divide 2 on ACLK
//    BCSCTL2 = SELM0 + SELM1 + SELS + DIVS0;       // XT1 -> MCLK, XT1 -> SMCLK
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//    TBCTL = TBSSEL0 + MC1;  //TBSSEL0 = TBCLK, MC1 = Cont. mode (Counts up to TBCL0)
//    TBCCTL0 = CAP + CCIE + CM0; //Rising Edge Capture, Enable interrupt,
//
//    P4SEL = BIT0;         //P4.0  For connecting Timer B input (need to connect source clock to this pin)
//
//    TACTL = TASSEL_2 + MC0 + ID1 + ID0;                  // SMCLK, up mode  CLOCK divide by two on timer side
//    TACCR0 = 10000 - 1;                         // 25Hz (40ms)
//    TACCR1 = (int)TACCR0 * 0.5;                 //50% duty cycle
//    TACCTL1  = OUTMOD_7;                          // TACCR1 25% PWM duty cycle
//
//    P1DIR = BIT6 + BIT5 + BIT7; //SET pins as output
//    P1SEL |= BIT6 + BIT5;   //SELECT pin 6
//
//    ADC10CTL0 = ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//    ADC10CTL1 = INCH3 + INCH2 + INCH1 + INCH0 + ADC10SSEL1 + ADC10SSEL0 + CONSEQ1;  //A15 ACCZ
//    ADC10AE1 = BIT7; //A15 select
//    ADC10SA = 0x0200;                         // Data buffer start
//    ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
//
//    P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//    UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//    UCA0BR0 = 1666 & 0xFF;                // Set baud rate
//    UCA0BR1 = 1666 >> 8;
//    UCA0MCTL = UCBRS_6;                   // Set modulation bits
////    IE2 |= UCA0RXIE;                      // Enable Rx interrupt
//    _EINT();
//
//    while(1){
////            while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
////            UCA0TXBUF = Result;  // Echo the byte back X
//            valueflag = 0; //clear flag now that value is written out
//
//            buffer[end] = Result;
//            end = (end+1)%16; //circular buffer return to first index if exceed 50
//            size++;
//
//            double sum = 0;
//            int i = 0;
//            for(i = 0; i<16; i++){
//                sum += buffer[i];
//            }
//            average = sum/16;
//            float fraction = (((float)average-(float)90))/(float)70;
//            if(fraction > 1){
//                fraction = 1;
//            }
//            if(fraction < 0){
//                fraction = 0;
//            }
//            TACCR1 = (int)TACCR0 * fraction;
//    }
//}

//
//
////EXERCISE 7.4   ADC
//#include <msp430.h>
//
//volatile unsigned int Result;
//#pragma vector=ADC10_VECTOR
//__interrupt void ADC10_ISR(void)
//{
////  _BIS_SR(GIE);                 // any interrupt is served even if the current routine is not concluded.
////  STIM_POWER_SUPPLY_nSHDN_PxOUT |= STIM_POWER_SUPPLY_nSHDN_PIN;
////    while((ADC10CTL1 & ADC10BUSY)!=0);
////    Result = ADC10MEM >> 2;
//    while((ADC10CTL1 & ADC10BUSY)!=0);
//    Result = ADC10MEM >> 2;
//
//     ADC10CTL0 &= ~ADC10IFG;
//}
//
//#pragma vector=USCIAB0RX_VECTOR // defined in "msp430x22x4.h"
//__interrupt void UART_RX(void) // interrupt on incoming data
//{
//    unsigned char rx_byte;
//    rx_byte = UCA0RXBUF; // grab byte from RX buffer
//
//
//}
//
//int main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//    BCSCTL2 = SELM0 + SELM1 + SELS;       // XT1 -> MCLK, XT1 -> SMCLK
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
////
////    TBCTL = TBSSEL0 + MC1;
////    TBCCTL0 = CAP + CCIE + CM1;
//
//    P4SEL = BIT0;
//
////    TACTL = TASSEL0 + MC0;                  // SMCLK, up mode  CLOCK divide by two on timer side
////    TACCR0 = 32000 - 1;                         // PWM Period 500,000Hz / 1000
////    TACCTL0 = OUTMOD2;                       // TACCR1 reset/set
////    TACCR1 = (int)TACCR0 * 0.25;
////    TACCTL1  = OUTMOD_7;                          // TACCR1 25% PWM duty cycle
//
//    ADC10CTL0 = ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//    ADC10CTL1 = INCH3 + INCH2 + INCH1 + INCH0 + ADC10SSEL1 + ADC10SSEL0 + CONSEQ1;  //A15 ACCZ
//    ADC10AE1 = BIT7; //A15 select
//    ADC10SA = 0x0200;                         // Data buffer start
//    ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
//
//    P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//    UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//    UCA0BR0 = 1666 & 0xFF;                // Set baud rate
//    UCA0BR1 = 1666 >> 8;
//    UCA0MCTL = UCBRS_6;                   // Set modulation bits
////    IE2 |= UCA0RXIE;                      // USCI_A0 receive interrupt enable
////    IE2 |= UCA0TXIE;                        // ENABLE  USCI_A0 TX interrupt
////    _EINT();
//    __enable_interrupt();                     // Enable interrupts
//    for(;;){
////        while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
////        UCA0TXBUF = 0xFF;  // Echo the byte back 255 starting bit
//
//        ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//        ADC10CTL1 = INCH3 + INCH2 + INCH0;  //A13 ACCX
//        ADC10CTL1 |= ADC10SSEL1 + ADC10SSEL0;
//        ADC10AE1 = BIT5; //A13 select
//        ADC10SA = 0x0200;                         // Data buffer start
//        ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
//        while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//        UCA0TXBUF = Result;  // Echo the byte back X
//
//        ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//        ADC10CTL1 = INCH3 + INCH2 + INCH1;  //A14 ACCY
//        ADC10CTL1 |= ADC10SSEL1 + ADC10SSEL0;
//        ADC10AE1 = BIT6; //A14 select
//        ADC10SA = 0x0200;                         // Data buffer start
//        ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
//        while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//        UCA0TXBUF = Result;  // Echo the byte back Y
//
//        ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE; //Turn on ADC 10 //Interrupt enabled
//        ADC10CTL1 = INCH3 + INCH2 + INCH1 + INCH0;  //A15 ACCZ
//        ADC10CTL1 |= ADC10SSEL1 + ADC10SSEL0;
//        ADC10AE1 = BIT7; //A15 select
//        ADC10SA = 0x0200;                         // Data buffer start
//        ADC10CTL0 |= ENC + ADC10SC;               // Start sampling continously
//        while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//        UCA0TXBUF = Result;  // Echo the byte back Z
//    }
//}


//EXERCISE 6.1   Timer Up Count Mode
//#include <msp430.h>
//volatile unsigned int falling;
//volatile unsigned int compare2;
//volatile unsigned int compare3;
//volatile unsigned int rising;
//volatile unsigned int check;
//volatile unsigned int range;
//int main(void)
//{
//
//          WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
//            BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq //DIVA0 for divide 2 on ACLK
//            BCSCTL2 = SELM0 + SELM1;       // XT1 -> MCLK, XT1 -> SMCLK
//            BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//            TBCTL = TBSSEL0 + MC1;  //TBSSEL0 = TBCLK, MC1 = Cont. mode (Counts up to TBCL0)
//            TBCCTL0 = CAP + CCIE + CM1; //Falling Edge Capture, Enable interrupt,
//
//            P4SEL = BIT0;         //P4.0
//
//            TACTL = TASSEL0 + MC0;                  // ACLK, up mode, ID0 would be CLOCK divide by two on timer side
//          TACCR0 = 32000- 1;                         // PWM Period 500,000Hz / 1000
//          TACCTL0 = OUTMOD2;                       // TACCR1 reset/set
//          TACCR1 = (int)TACCR0 * 0.25;
//          TACCTL1  = OUTMOD_7;                          // TACCR1 25% PWM duty cycle
//
//
//          P1DIR = BIT6 + BIT5; //SET pins as output
//          P1SEL |= BIT6 + BIT5;   //SELECT pin 6
//
//    _EINT();
//
//    while(1);
//}
//
//#pragma vector=TIMERB0_VECTOR
//__interrupt void Timer_B(void)
//{
//    TBCTL &= ~CCIFG;
//    if(check == 1){
//        rising = TBCCR0;
//        check = 2;
//    }
//    else if(check == 2){
//        check = 1;
//        falling = TBCCR0;
//
//        if(rising > falling){
//            range = 65535 + falling - rising;
//        }
//        else{
//        range = falling - rising;
//        }
//        range = range;
////        compare2 = compare /1000*4;
////        compare3 = 16000 / compare2;
//    }
//    else if(check == 0){
//        check = 1;
//        TBCCTL0 |= CM0;
//    }
//  }


//EXERCISE 5.3   Timer Up Count Mode Pin 1.6 output 500 Hz, 25% duty
//#include <msp430.h>
//
//int main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//    BCSCTL2 = SELM0 + SELM1 + SELS + DIVS1;       // XT1 -> MCLK, XT1 -> SMCLK Divde by 4
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//

//
//  TACCR0 = 1000 - 1;                         // PWM Period 500,000Hz / 1000
//  TACCTL1 = OUTMOD_7;           //PIN 1.6            // TACCR1 reset/set
//  TACCR1 = (int)TACCR0*0.25;                             // TACCR1 25% PWM duty cycle
//
//  TACTL = TASSEL_2 + MC_1 + ID1 + ID0;                  // SMCLK, up mode  CLOCK divide by eight on timer side
//
//  for(;;){
//
//  }
////  __bis_SR_register(CPUOFF);                // Enter LPM0
//}

//EXERCISE 5.3   Timer Up Count Mode Pin 1.7 Version output 500 Hz 25% duty
//#include <msp430.h>
//
//int main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//    BCSCTL2 = SELM0 + SELM1 + SELS + DIVS1 + DIVS0;       // XT1 -> MCLK, XT1 -> SMCLK Divde by 4
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//      P1DIR |= BIT7; //SET pins as output
//      P1SEL |= BIT7;   //SELECT pin 6
//
//  TACCR0 = 1000 - 1;                         // PWM Period 500,000Hz / 1000
//  TACCTL2 = OUTMOD_7;    //RESET TOGGLE Pin 1.7
//  TACCR2 = (int)TACCR0*0.25;                             // TACCR1 25% PWM duty cycle
//
//  TACTL = TASSEL_2 + MC_1 + ID1;                  // SMCLK, up mode  CLOCK divide by eight on timer side
//
//  for(;;){
//
//  }
////  __bis_SR_register(CPUOFF);                // Enter LPM0
//}

//EXERCISE 5.2   Timer Up Count Mode Count to TACCR0
//#include <msp430.h>
//
//int main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//    BCSCTL2 = SELM0 + SELM1 + SELS + DIVS1;       // XT1 -> MCLK, XT1 -> SMCLK
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//    P1DIR |= BIT5; //SET pins as output
//    P1SEL |= BIT5;   //SELECT pin 5
//
//    TACCR0 = 1000 - 1;                         // PWM Period 500,000Hz / 1000
//    TACCTL0 = OUTMOD_4;                        // TOGGLE MODE
//    TACTL = TASSEL_2 + MC0 + ID1;              // SMCLK, up mode  CLOCK divide by two on timer side
//    //Note MC_1 == MC0
//    for(;;){
//
//    }
////    __bis_SR_register(CPUOFF);                // Enter LPM0
//}

//
////EXERCISE 5.2   Timer Cont. Count Mode Count to 0xFFFFh 122Hz
//#include <msp430.h>
//
//int main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//    BCSCTL2 = SELM0 + SELM1 + SELS;       // XT1 -> MCLK, XT1 -> SMCLK
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//    P1DIR |= BIT5; //SET pins as output
//    P1SEL |= BIT5;   //SELECT pin 5
//
//    TACCR0 = 1000 - 1;                         // PWM Period 500,000Hz / 1000
//    TACCTL0 = OUTMOD_4;                        // TOGGLE MODE
//    TACTL = TASSEL_2 + MC1;                  // SMCLK, cont. mode  CLOCK divide by two on timer side
//
//    for(;;){
//
//    }
////    __bis_SR_register(CPUOFF);                // Enter LPM0
//}


//
//
//EXERCISE 4.4   57.6k baud
//#include "msp430x22x4.h"
//
//#pragma vector=USCIAB0RX_VECTOR // defined in "msp430x22x4.h"
//__interrupt void UART_RX(void) // interrupt on incoming data
//{
//    unsigned char rx_byte;
//    rx_byte = UCA0RXBUF; // grab byte from RX buffer
//
//    if(rx_byte == 0x6A){  //j ascii
//        P1DIR |= BIT7;
//        P1OUT |= BIT7;  //Turn on LED3
//    }
//    else if(rx_byte == 0x6B){ //k ascii
//        P1OUT = 0;     //Turn off LED3
//    }
//
//    while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//    UCA0TXBUF = rx_byte;  // Echo the byte back
//    while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//    UCA0TXBUF = rx_byte + 1;  // Echo the byte back
//}
//
//void main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;             // Stop watchdog timer
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//    BCSCTL2 = SELM0 + SELM1 + SELS;       // XT1 -> MCLK, XT1 -> SMCLK
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//    P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//
//    UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//    UCA0BR0 = 278 & 0xFF;                // Set baud rate  16MHz/57600baud = 277.7777
//    UCA0BR1 = 278 >> 8;
//    UCA0MCTL = UCBRS_6;                   // Set modulation bits
//    IE2 |= UCA0RXIE;                      // Enable Rx interrupt
//
//    _EINT();      // Global interrupt enable
//    //  for(;;){
//    //
//    //      while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//    //      UCA0TXBUF = 0x61;  // Echo the byte back
//    //      __delay_cycles(1*10000);
//    //  }
//    while (1);
//}


//EXERCISE 4.3
//#include "msp430x22x4.h"
//
//#pragma vector=USCIAB0RX_VECTOR // defined in "msp430x22x4.h"
//__interrupt void UART_RX(void) // interrupt on incoming data
//{
//    unsigned char rx_byte;
//    rx_byte = UCA0RXBUF; // grab byte from RX buffer
//
//    if(rx_byte == 0x6A){  //j ascii
//        P1DIR |= BIT7;
//        P1OUT |= BIT7;  //Turn on LED3
//    }
//    else if(rx_byte == 0x6B){ //k ascii
//        P1OUT = 0;     //Turn off LED3
//    }
//
//    while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//    UCA0TXBUF = rx_byte;  // Echo the byte back
//    while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//    UCA0TXBUF = rx_byte + 1;  // Echo the byte back
//
//
//}
//
//void main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;             // Stop watchdog timer
//    BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//    BCSCTL2 = SELM0 + SELM1 + SELS;       // XT1 -> MCLK, XT1 -> SMCLK
//    BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//    P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//
//    UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//    UCA0BR0 = 1666 & 0xFF;                // Set baud rate
//    UCA0BR1 = 1666 >> 8;
//    UCA0MCTL = UCBRS_6;                   // Set modulation bits
//    IE2 |= UCA0RXIE;                      // Enable Rx interrupt
//
//    _EINT();      // Global interrupt enable
//    //  for(;;){
//    //
//    //      while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//    //      UCA0TXBUF = 0x61;  // Echo the byte back
//    //      __delay_cycles(1*10000);
//    //  }
//    while (1);
//}


////EXERCISE 4.2
//#include "msp430x22x4.h"
//
//#pragma vector=USCIAB0RX_VECTOR // defined in "msp430x22x4.h"
//__interrupt void UART_RX(void) // interrupt on incoming data
//{
//  unsigned char rx_byte;
//  rx_byte = UCA0RXBUF; // grab byte from RX buffer
//  while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//  UCA0TXBUF = rx_byte;  // Echo the byte back
//  while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//  UCA0TXBUF = rx_byte + 1;  // Echo the byte back
//}
//
//void main(void)
//{
//  WDTCTL = WDTPW + WDTHOLD;             // Stop watchdog timer
//  BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//  BCSCTL2 = SELM0 + SELM1 + SELS;       // XT1 -> MCLK, XT1 -> SMCLK
//  BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//  P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//
//  UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//  UCA0BR0 = 1666 & 0xFF;                // Set baud rate
//  UCA0BR1 = 1666 >> 8;
//  UCA0MCTL = UCBRS_6;                   // Set modulation bits
//  IE2 |= UCA0RXIE;                      // Enable Rx interrupt
//
//  _EINT();      // Global interrupt enable
////  for(;;){
////
////      while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
////      UCA0TXBUF = 0x61;  // Echo the byte back
////      __delay_cycles(1*10000);
////  }
//  while (1);
//}

//
////EXERCISE 4.1
//#include "msp430x22x4.h"
//
//#pragma vector=USCIAB0RX_VECTOR // defined in "msp430x22x4.h"
//__interrupt void UART_RX(void) // interrupt on incoming data
//{
//  unsigned char rx_byte;
//  rx_byte = UCA0RXBUF; // grab byte from RX buffer
//  while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//  UCA0TXBUF = rx_byte;  // Echo the byte back
//}
//
//void main(void)
//{
//  WDTCTL = WDTPW + WDTHOLD;             // Stop watchdog timer
//  BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//  BCSCTL2 = SELM0 + SELM1 + SELS;       // XT1 -> MCLK, XT1 -> SMCLK
//  BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//  P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//
//  UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//  UCA0BR0 = 1666 & 0xFF;                // Set baud rate
//  UCA0BR1 = 1666 >> 8;
//  UCA0MCTL = UCBRS_6;                   // Set modulation bits
//  IE2 |= UCA0RXIE;                      // Enable Rx interrupt
//
//  _EINT();      // Global interrupt enable
//  for(;;){
//
//      while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//      UCA0TXBUF = 0x61;  // Echo the byte back
//      __delay_cycles(1*10000);
//  }
////  while (1);
//}



////EXERCISE3
////
////#include "msp430x22x4.h"
//#include <msp430.h>
//void main(void)
//{
//    WDTCTL = WDTPW + WDTHOLD;        // Stop watchdog timer
//    P1OUT &= 0x00;                   // Errthing off!
//    P1DIR &= 0x00;
//    P1DIR |= BIT1;                   //P1.1 output
//    P1IE |= BIT0;                    // P1.3 interrupt enabled
//    P1IES = 0;                   //Set to low-to-high transition interrupt edge select register
//    _BIS_SR(LPM4_bits + GIE);        // Enter LPM4 w/interrupt
//
//}
//// Port 1 interrupt service routine
//#pragma vector=PORT1_VECTOR
//__interrupt void Port_1(void)
//{
//   P1OUT ^= BIT1;                        // Toggle P1.1
//   P1IFG &=~BIT0;                        // P1.0 IFG cleared
//}


//EXERCISE 2
//#include "msp430x22x4.h"
//#include <msp430.h>
//void main(void)
//{
//    volatile unsigned int i;                              // volatile to prevent optimization
//    WDTCTL = WDTPW + WDTHOLD;                             // Stop watchdog timer
//
//    P1DIR |= (BIT0+BIT1+BIT2+BIT3+BIT4+BIT5+BIT6+BIT7);   //P1.0 to P1.7 Output
//    P1OUT = 0x93; //10010011
//    for (;;)
//    {
//        P1OUT = ~P1OUT;                       // Toggle P1.0 using complement
//        __delay_cycles(1*1000000);            //1 second delay
//    }
//}




////EXERCISE 1
//#include "msp430x22x4.h"
//
//void main(void)
//{
//  WDTCTL = WDTPW + WDTHOLD;             // Stop watchdog timer
//  BCSCTL1 = XT2OFF + XTS + RSEL2;               // XT2 off, XT1 high freq
//
//  //set SMCLK divider = 4
//  BCSCTL2 = SELM_3 + DIVS_2;
//  BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//  //DCO to 500kHz
//  DCOCTL = DCO1 + DCO2;                        //DCO = 7, RSEL = 0, approx 500kHz
//  //DCOCTL = DCO0 + DCO1 + DCO2;                        //DCO = 7, RSEL = 0, approx 500kHz
//  //DCOCTL = 0xB0;
//
//  //P2.1 to SMCLK OUT
//  P2DIR |= BIT1;
//  P2SEL |= 0x03;
//  //P2SEL |= 0x02;
//
//  while(1);
//}










//#include "msp430x22x4.h"
//
//#pragma vector=USCIAB0RX_VECTOR // defined in "msp430x22x4.h"
//__interrupt void UART_RX(void) // interrupt on incoming data
//{
//  unsigned char rx_byte;
//  rx_byte = UCA0RXBUF; // grab byte from RX buffer
//  while((IFG2 & UCA0TXIFG) == 0); // wait for TX buffer to be clear
//  UCA0TXBUF = rx_byte;  // Echo the byte back
//}
//



//EXAMPLE CLOCK AND UART
//void main(void)
//{
//  WDTCTL = WDTPW + WDTHOLD;             // Stop watchdog timer
//  BCSCTL1 = XT2OFF + XTS;               // XT2 off, XT1 high freq
//  BCSCTL2 = SELM0 + SELM1 + SELS;       // XT1 -> MCLK, XT1 -> SMCLK
//  BCSCTL3 = LFXT1S1;                    // XT1 freq 3-16 MHz
//
//  P3SEL = BIT4 | BIT5;                  // Set up ports 3.4 and 3.5 as UART ports
//
//  UCA0CTL1 = UCSSEL1;                   // Use SMCLK for UART
//  UCA0BR0 = 1666 & 0xFF;                // Set baud rate
//  UCA0BR1 = 1666 >> 8;
//  UCA0MCTL = UCBRS_6;                   // Set modulation bits
//  IE2 |= UCA0RXIE;                      // Enable Rx interrupt
//
//  _EINT();      // Global interrupt enable
//
//  while (1);
//}


//EXAMPLE BLINK
//#include <msp430.h>
//
//
//void main(void)
//{
//    volatile unsigned int i;            // volatile to prevent optimization
//
//      WDTCTL = WDTPW + WDTHOLD;             // Stop watchdog timer
//      P1DIR |= (BIT0+BIT1+BIT2+BIT3+BIT4+BIT5+BIT6+BIT7);
//  //    P1DIR |= BIT7;
//      //P1SEL |= BIT0|BIT1|BIT2|BIT3|BIT4|BIT5|BIT6|BIT7|;
//    //P1OUT = 0x93; //10010011
//      for (;;)
//      {
//
//        P1OUT ^= BIT7;                      // Toggle P1.0 using exclusive-OR
//
//        i = 10000;                          // SW Delay
//        do i--;
//        while (i != 0);
//      }
//
//}
